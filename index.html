<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="LightNote v1 — a tiny, private, offline journal. Your notes stay in your browser." />
  <meta name="theme-color" content="#0f0f12" />
  <meta name="color-scheme" content="dark light" />

  <title>LightNote v1 — tiny journal</title>
  <!-- simple text favicon (SVG data URL) -->
  <link rel="icon" href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="100%" height="100%" fill="%2316161b"/><text x="50%" y="56%" dominant-baseline="middle" text-anchor="middle" font-family="sans-serif" font-size="42" fill="%238ab4f8">LN</text></svg>' />
  <script src="sentiment.js"></script>
  <script type="module">
    import { initInsights } from './js/weeklyInsights.js';
    // Initialize insights when loading the insights route
    const observer = new MutationObserver(() => {
      const insightsView = document.querySelector('[data-route="insights"]');
      if (insightsView && window.getComputedStyle(insightsView).display !== 'none') {
        initInsights();
      }
    });
    observer.observe(document.body, { 
      attributes: true, 
      subtree: true,
      attributeFilter: ['style']
    });
  </script>
  <style>
    .nav {
      display: flex;
      gap: 1rem;
      margin-left: 2rem;
      align-items: center;
    }
    .nav-link {
      text-decoration: none;
      color: inherit;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      transition: background-color 0.2s;
      font-size: 0.9rem;
      opacity: 0.8;
    }
    .nav-link:hover,
    .nav-link.active {
      background-color: rgba(255, 255, 255, 0.1);
      opacity: 1;
    }
    .flex {
      display: flex;
      align-items: center;
    }
    h1 {
      font-size: 1.2rem;
      font-weight: 500;
      margin: 0;
    }
    .version {
      opacity: 0.7;
      font-weight: normal;
    }
  </style>
  <script>
    // Router
    function route(){
      const hash = location.hash || '#/write';
      document.querySelectorAll('[data-route]').forEach(el => {
        el.style.display = ('#/'+el.dataset.route === hash) ? '' : 'none';
      });
      // Update active nav link
      document.querySelectorAll('.nav-link').forEach(link => {
        link.classList.toggle('active', link.getAttribute('href') === hash);
      });
    }
    window.addEventListener('hashchange', route);
    window.addEventListener('load', route);

    // Constants

    const LEXICON = lexicon;

    // Define STOP words set at the top level
    const STOP = new Set([
      "a","about","above","after","again","against","all","am","an","and","any","are",
      "aren't","as","at","be","because","been","before","being","below","between",
      "both","but","by","can","cannot","could","couldn't","did","didn't","do","does",
      "doesn't","doing","don't","down","during","each","few","for","from","further",
      "had","hadn't","has","hasn't","have","haven't","having","he","he'd","he'll",
      "he's","her","here","here's","hers","herself","him","himself","his","how",
      "how's","i","id","ill","im","ive","if","in","into","is","isn't","it","it's",
      "its","itself","let's","me","more","most","mustn't","my","myself","no","nor",
      "not","of","off","on","once","only","or","other","ought","our","ours",
      "ourselves","out","over","own","same","she","she'd","she'll","she's","should",
      "shouldn't","so","some","such","than","that","that's","the","their","theirs",
      "them","themselves","then","there","there's","these","they","they'd","they'll",
      "they're","they've","this","those","through","to","too","under","until","up",
      "very","was","wasn't","we","we'd","we'll","we're","we've","were","weren't",
      "what","what's","when","when's","where","where's","which","while","who","who's",
      "whom","why","why's","with","won't","would","wouldn't","you","you'd","you'll",
      "you're","you've","your","yours","yourself","yourselves"
    ]);

// (empirically derived mean sentiment intensity rating increase for booster words)
const B_INCR = 0.293;

const B_DECR = -0.293;

// (empirically derived mean sentiment intensity rating increase for using
// ALLCAPs to emphasize a word)
const C_INCR = 0.733;

const N_SCALAR = -0.74;

const REGEX_REMOVE_PUNCTUATION = new RegExp(
  /[!"#$%&'()*+,-./:;<=>?@[\\\]^_`{|}~]/g
);

// ` // <- to fix ide thinking grave accent in regex is starting a template quote
const PUNC_LIST = [
  ".",
  "!",
  "?",
  ",",
  ";",
  ":",
  "-",
  "'",
  '"',
  "!!",
  "!!!",
  "??",
  "???",
  "?!?",
  "!?!",
  "?!?!",
  "!?!?",
];

const NEGATE = [
  "aint",
  "arent",
  "cannot",
  "cant",
  "couldnt",
  "darent",
  "didnt",
  "doesnt",
  "ain't",
  "aren't",
  "can't",
  "couldn't",
  "daren't",
  "didn't",
  "doesn't",
  "dont",
  "hadnt",
  "hasnt",
  "havent",
  "isnt",
  "mightnt",
  "mustnt",
  "neither",
  "don't",
  "hadn't",
  "hasn't",
  "haven't",
  "isn't",
  "mightn't",
  "mustn't",
  "neednt",
  "needn't",
  "never",
  "none",
  "nope",
  "nor",
  "not",
  "nothing",
  "nowhere",
  "oughtnt",
  "shant",
  "shouldnt",
  "uhuh",
  "wasnt",
  "werent",
  "oughtn't",
  "shan't",
  "shouldn't",
  "uh-uh",
  "wasn't",
  "weren't",
  "without",
  "wont",
  "wouldnt",
  "won't",
  "wouldn't",
  "rarely",
  "seldom",
  "despite",
];


    // booster/dampener 'intensifiers' or 'degree adverbs'
    // http://en.wiktionary.org/wiki/Category:English_degree_adverbs

    const BOOSTER_DICT = {
      absolutely: B_INCR,
      amazingly: B_INCR,
      awfully: B_INCR,
      completely: B_INCR,
      considerably: B_INCR,
      decidedly: B_INCR,
      deeply: B_INCR,
      effing: B_INCR,
      enormously: B_INCR,
      entirely: B_INCR,
      especially: B_INCR,
      exceptionally: B_INCR,
      extremely: B_INCR,
      fabulously: B_INCR,
      flipping: B_INCR,
      flippin: B_INCR,
      fricking: B_INCR,
      frickin: B_INCR,
      frigging: B_INCR,
      friggin: B_INCR,
      fully: B_INCR,
      fucking: B_INCR,
      greatly: B_INCR,
      hella: B_INCR,
      highly: B_INCR,
      hugely: B_INCR,
      incredibly: B_INCR,
      intensely: B_INCR,
      majorly: B_INCR,
      more: B_INCR,
      most: B_INCR,
      particularly: B_INCR,
      purely: B_INCR,
      quite: B_INCR,
      really: B_INCR,
      remarkably: B_INCR,
      so: B_INCR,
      substantially: B_INCR,
      thoroughly: B_INCR,
      totally: B_INCR,
      tremendously: B_INCR,
      uber: B_INCR,
      unbelievably: B_INCR,
      unusually: B_INCR,
      utterly: B_INCR,
      very: B_INCR,
      almost: B_DECR,
      barely: B_DECR,
      hardly: B_DECR,
      "just enough": B_DECR,
      "kind of": B_DECR,
      kinda: B_DECR,
      kindof: B_DECR,
      "kind-of": B_DECR,
      less: B_DECR,
      little: B_DECR,
      marginally: B_DECR,
      occasionally: B_DECR,
      partly: B_DECR,
      scarcely: B_DECR,
      slightly: B_DECR,
      somewhat: B_DECR,
      "sort of": B_DECR,
      sorta: B_DECR,
      sortof: B_DECR,
      "sort-of": B_DECR,
    };

    // check for special case idioms using a sentiment-laden keyword known to VADER
    const SPECIAL_CASE_IDIOMS = {
      "the shit": 3,
      "the bomb": 3,
      "bad ass": 1.5,
      "yeah right": -2,
      "cut the mustard": 2,
      "kiss of death": -1.5,
      "hand to mouth": -2,
    };

    // static methods

    const negated = (input_words, include_nt = true) => {
      /**
        Determine if input contains negation words
      */

      let neg_words = [];
      neg_words.push.apply(neg_words, NEGATE);
      for (let i = 0; i < neg_words.length; i++) {
        if (input_words.indexOf(neg_words[i]) >= 0) {
          return true;
        }
      }
      if (include_nt === true) {
        for (let i = 0; i < input_words.length; i++) {
          if (input_words[i].indexOf("n't") >= 0) {
            return true;
          }
        }
      }
      const i = input_words.findIndex((element) => {
        return element === "least";
      });
      return i !== -1 && i > 0 && input_words[i - 1] !== "at";
    };

    const normalize = (score, alpha = 15) => {
      /**
        Normalize the score to be between -1 and 1 using an alpha that
        approximates the max expected value
      */

      const norm_score = score / Math.sqrt(score * score + alpha);
      if (norm_score < -1.0) {
        return -1.0;
      } else if (norm_score > 1.0) {
        return 1.0;
      } else {
        return norm_score;
      }
    };

    const allcap_differential = (words) => {
      /**
        Check whether just some words in the input are ALL CAPS
      */

      let allcap_words = 0;
      for (let i = 0; i < words.length; i++) {
        if (is_upper_python(words[i])) {
          allcap_words += 1;
        }
      }
      const cap_differential = words.length - allcap_words;
      return cap_differential > 0 && cap_differential < words.length;
    };

    const scalar_inc_dec = (word, valence, is_cap_diff) => {
      /**
          Check if the preceding words increase, decrease, or negate/nullify the
          valence
        */

      let scalar = 0.0;
      const word_lower = word.toLowerCase();
      if (BOOSTER_DICT.hasOwnProperty(word_lower)) {
        scalar = BOOSTER_DICT[word_lower];
        if (valence < 0) {
          scalar *= -1;
        }
        // check if booster/dampener word is in ALLCAPS (while others aren't)
        if (is_cap_diff && is_upper_python(word)) {
          if (valence > 0) {
            scalar += C_INCR;
          } else {
            scalar -= C_INCR;
          }
        }
      }
      return scalar;
    };

    const is_upper_python = (word) => {
      /**
          Python style "isupper" function. Requirements are that the string is at least one character in length,
          and does not consider an emoticon, e.g. :), as an uppercase word, but a string with special characters and only
          all caps characters is an uppercase word, e.g. ':)WORD' is true
      */
      if (typeof word === "string" || word instanceof String) {
        if (word.length > 0) {
          return /^[^a-z]*[A-Z]+[^a-z]*$/g.test(word);
        }
      }
      return false;
    };

    class SentiText {
      /**
        Identify sentiment-relevant string-level properties of input text
      */
      constructor(text) {
        this.text = text;
        this.words_and_emoticons = this.get_words_and_emoticons();
        // doesn't separate words from adjacent punctuation (keeps emoticons & contractions)
        this.is_cap_diff = allcap_differential(this.words_and_emoticons);
      }

      get_words_plus_punc() {
        /**
            Returns mapping of form:
            {
              'cat,': 'cat',
              ',cat': 'cat'
            }
          */

        // removes punctuation (but loses emoticons & contractions)
        const no_punc_text = this.text
          .slice(0)
          .replace(REGEX_REMOVE_PUNCTUATION, "");
        const words = no_punc_text.split(/\s/);
        // removes singletons
        const words_only = words.filter((word) => {
          return word.length > 1;
        });
        let words_punc_dict = {};
        for (let j = 0; j < PUNC_LIST.length; j++) {
          for (let k = 0; k < words_only.length; k++) {
            let pb = `${PUNC_LIST[j]}${words_only[k]}`;
            let pa = `${words_only[k]}${PUNC_LIST[j]}`;
            words_punc_dict[pb] = words_only[k];
            words_punc_dict[pa] = words_only[k];
          }
        }
        return words_punc_dict;
      }

      get_words_and_emoticons() {
        /**
          Removes leading and trailing puncutation
          Leaves contractions and most emoticons
          Does not preserve punc-plus-letter emoticons (e.g. :D)
        */

        const tokens = this.text.split(/\s/);
        const words_punc_dict = this.get_words_plus_punc();
        let words_only = tokens.filter((token) => {
          return token.length > 1;
        });
        for (let i = 0; i < words_only.length; i++) {
          if (words_punc_dict.hasOwnProperty(words_only[i])) {
            words_only[i] = words_punc_dict[words_only[i]];
          }
        }
        return words_only;
      }
    }

    class SentimentIntensityAnalyzer {
      /**
        Give a sentiment intensity score to sentences
      */

      static polarity_scores(text) {
        /**
          Return a float for sentiment strength based on the input text.
          Positive values are positive valence, negative value are negative
          valence
        */

        const sentiText = new SentiText(text);
        let sentiments = [];
        const words_and_emoticons = sentiText.words_and_emoticons;
        for (let i = 0; i < words_and_emoticons.length; i++) {
          let valence = 0;
          const item = words_and_emoticons[i];
          if (
            (i < words_and_emoticons.length - 1 &&
              item.toLowerCase() === "kind" &&
              words_and_emoticons[i + 1].toLowerCase() === "of") ||
            BOOSTER_DICT.hasOwnProperty(item.toLowerCase())
          ) {
            sentiments.push(valence);
            continue;
          }

          sentiments = SentimentIntensityAnalyzer.sentiment_valence(
            valence,
            sentiText,
            item,
            i,
            sentiments
          );
        }

        sentiments = SentimentIntensityAnalyzer.but_check(
          words_and_emoticons,
          sentiments
        );
        const valence_dict = SentimentIntensityAnalyzer.score_valence(
          sentiments,
          text
        );
        return valence_dict;
      }

      static sentiment_valence(valence, sentiText, item, index, sentiments) {
        const is_cap_diff = sentiText.is_cap_diff;
        const words_and_emoticons = sentiText.words_and_emoticons;
        const item_lowercase = item.toLowerCase();
        if (LEXICON.hasOwnProperty(item_lowercase)) {
          // get the sentiment valence
          valence = LEXICON[item_lowercase];
          // check if sentiment laden word is in ALL CAPS (while others aren't)
          if (is_upper_python(item) && is_cap_diff) {
            if (valence > 0) {
              valence += C_INCR;
            } else {
              valence -= C_INCR;
            }
          }

          for (let start_i = 0; start_i < 3; start_i++) {
            if (
              index > start_i &&
              LEXICON.hasOwnProperty(
                words_and_emoticons[index - (start_i + 1)].toLowerCase()
              ) === false
            ) {
              // dampen the scalar modifier of preceding words and emoticons
              // (excluding the ones that immediately preceed the item) based
              // on their distance from the current item.
              let s = scalar_inc_dec(
                words_and_emoticons[index - (start_i + 1)],
                valence,
                is_cap_diff
              );
              if (start_i === 1 && s !== 0) {
                s = s * 0.95;
              } else if (start_i === 2 && s !== 0) {
                s = s * 0.9;
              }
              valence = valence + s;
              valence = this.never_check(
                valence,
                words_and_emoticons,
                start_i,
                index
              );
              if (start_i === 2) {
                valence = this.idioms_check(valence, words_and_emoticons, index);
              }
            }
          }

          valence = this.least_check(valence, words_and_emoticons, index);
        }

        sentiments.push(valence);
        return sentiments;
      }

      static least_check(valence, words_and_emoticons, index) {
        /**
          Check for negaion case using "least"
        */

        if (
          index > 1 &&
          words_and_emoticons[index - 1].toLowerCase() === "least" &&
          LEXICON.hasOwnProperty(words_and_emoticons[index - 1].toLowerCase()) ===
            false
        ) {
          if (
            words_and_emoticons[index - 2].toLowerCase() !== "at" &&
            words_and_emoticons[index - 2].toLowerCase() !== "very"
          ) {
            valence = valence * N_SCALAR;
          }
        } else if (
          index > 0 &&
          words_and_emoticons[index - 1].toLowerCase() === "least" &&
          LEXICON.hasOwnProperty(words_and_emoticons[index - 1].toLowerCase()) ===
            false
        ) {
          valence = valence * N_SCALAR;
        }

        return valence;
      }

      static but_check(words_and_emoticons, sentiments) {
        /**
          Check for modification in sentiment due to contrastive conjunction 'but'
        */
        let but_index = words_and_emoticons.indexOf("but");
        if (but_index === -1) {
          but_index = words_and_emoticons.indexOf("BUT");
        }
        if (but_index !== -1) {
          for (let i = 0; i < sentiments.length; i++) {
            const sentiment_index = i;
            const sentiment = sentiments[sentiment_index];
            if (sentiment_index < but_index) {
              sentiments.splice(sentiment_index, 1);
              sentiments.splice(sentiment_index, 0, sentiment * 0.5);
            } else if (sentiment_index > but_index) {
              sentiments.splice(sentiment_index, 1);
              sentiments.splice(sentiment_index, 0, sentiment * 1.5);
            }
          }
        }
        return sentiments;
      }

      static idioms_check(valence, words_and_emoticons, index) {
        const onezero = `${words_and_emoticons[index - 1]} ${
          words_and_emoticons[index]
        }`;
        const twoonezero = `${words_and_emoticons[index - 2]} ${
          words_and_emoticons[index - 1]
        } ${words_and_emoticons[index]}`;
        const twoone = `${words_and_emoticons[index - 2]} ${
          words_and_emoticons[index - 1]
        }`;
        const threetwoone = `${words_and_emoticons[index - 3]} ${
          words_and_emoticons[index - 2]
        } ${words_and_emoticons[index - 1]}`;
        const threetwo = `${words_and_emoticons[index - 3]} ${
          words_and_emoticons[index - 2]
        }`;

        const sequences = [onezero, twoonezero, twoone, threetwoone, threetwo];

        for (let i = 0; i < sequences.length; i++) {
          if (SPECIAL_CASE_IDIOMS.hasOwnProperty(sequences[i])) {
            valence = SPECIAL_CASE_IDIOMS[sequences[i]];
            break;
          }
        }

        if (words_and_emoticons.length - 1 > index) {
          const zeroone = `${words_and_emoticons[index]} ${
            words_and_emoticons[index + 1]
          }`;
          if (SPECIAL_CASE_IDIOMS.hasOwnProperty(zeroone)) {
            valence = SPECIAL_CASE_IDIOMS[zeroone];
          }
        }

        if (words_and_emoticons.length - 1 > index + 1) {
          const zeroonetwo = `${words_and_emoticons[index]} ${
            words_and_emoticons[index + 1]
          } ${words_and_emoticons[index + 2]}`;
          if (SPECIAL_CASE_IDIOMS.hasOwnProperty(zeroonetwo)) {
            valence = SPECIAL_CASE_IDIOMS[zeroonetwo];
          }
        }

        // check for booster/dampener bi-grams such as 'sort of' or 'kind of'
        if (
          BOOSTER_DICT.hasOwnProperty(threetwo) ||
          BOOSTER_DICT.hasOwnProperty(twoone)
        ) {
          valence = valence + B_DECR;
        }

        return valence;
      }

      static never_check(valence, words_and_emoticons, start_i, index) {
        if (start_i === 0) {
          if (negated([words_and_emoticons[index - 1]])) {
            valence = valence * N_SCALAR;
          }
        }

        if (start_i === 1) {
          if (
            words_and_emoticons[index - 2] === "never" &&
            (words_and_emoticons[index - 1] === "so" ||
              words_and_emoticons[index - 1] === "this")
          ) {
            valence = valence * 1.5;
          } else if (negated([words_and_emoticons[index - (start_i + 1)]])) {
            valence = valence * N_SCALAR;
          }
        }

        if (start_i === 2) {
          if (
            (words_and_emoticons[index - 3] === "never" &&
              (words_and_emoticons[index - 2] === "so" ||
                words_and_emoticons[index - 2] === "this")) ||
            words_and_emoticons[index - 1] === "so" ||
            words_and_emoticons[index - 1] === "this"
          ) {
            valence = valence * 1.25;
          } else if (negated([words_and_emoticons[index - (start_i + 1)]])) {
            valence = valence * N_SCALAR;
          }
        }

        return valence;
      }

      static punctuation_emphasis(sum_s, text) {
        /**
          Add emphasis from exclamation points and question marks
        */

        const ep_amplifier = SentimentIntensityAnalyzer.amplify_ep(text);
        const qm_amplifier = SentimentIntensityAnalyzer.amplify_qm(text);
        const punct_emph_amplifier = ep_amplifier + qm_amplifier;
        return punct_emph_amplifier;
      }

      static amplify_ep(text) {
        /**
          Check for added emphasis resulting from exclamation points (up to 4 of them)
        */

        let ep_count = text.replace(/[^!]/g, "").length;
        if (ep_count > 4) {
          ep_count = 4;
        }
        // empirically derived mean sentiment intensity rating increase for exclamation points
        const ep_amplifier = ep_count * 0.292;
        return ep_amplifier;
      }

      static amplify_qm(text) {
        /**
          Check for added emphasis resulting from question marks (2 or 3+)
        */

        let qm_count = text.replace(/[^?]/g, "").length;
        let qm_amplifier = 0;
        if (qm_count > 1) {
          if (qm_count <= 3) {
            // empirically derived mean sentiment intensity rating increase for question marks
            qm_amplifier = qm_count * 0.18;
          } else {
            qm_amplifier = 0.96;
          }
        }

        return qm_amplifier;
      }

      static sift_sentiment_scores(sentiments) {
        /**
          Want separate positive versus negative sentiment scores
        */

        let pos_sum = 0.0;
        let neg_sum = 0.0;
        let neu_count = 0;

        for (let i = 0; i < sentiments.length; i++) {
          const sentiment_score = sentiments[i];
          if (sentiment_score > 0) {
            pos_sum += sentiment_score + 1; // compensates for neutral words that are counted as 1
          } else if (sentiment_score < 0) {
            neg_sum += sentiment_score - 1; // when used with math.fabs(), compensates for neutrals
          } else {
            neu_count += 1;
          }
        }
        const results = [pos_sum, neg_sum, neu_count];
        return results;
      }

      static score_valence(sentiments, text) {
        if (sentiments && sentiments.length > 0) {
          let sum_s = 0;
          for (let i = 0; i < sentiments.length; i++) {
            sum_s += sentiments[i];
          }
          // compute and add emphasis from punctuation in text
          const punct_emph_amplifier =
            SentimentIntensityAnalyzer.punctuation_emphasis(sum_s, text);
          if (sum_s > 0) {
            sum_s += punct_emph_amplifier;
          } else if (sum_s < 0) {
            sum_s -= punct_emph_amplifier;
          }

          let compound = normalize(sum_s);
          // discriminate between positive, negative and neutral sentiment scores
          let scores = SentimentIntensityAnalyzer.sift_sentiment_scores(sentiments);
          let pos_sum = scores[0];
          let neg_sum = scores[1];
          let neu_count = scores[2];

          if (pos_sum > Math.abs(neg_sum)) {
            pos_sum += punct_emph_amplifier;
          } else if (pos_sum < Math.abs(neg_sum)) {
            neg_sum -= punct_emph_amplifier;
          }

          const total = pos_sum + Math.abs(neg_sum) + neu_count;
          const pos = Math.abs(pos_sum / total);
          const neg = Math.abs(neg_sum / total);
          const neu = Math.abs(neu_count / total);
          const sentiment_dict = {
            neg: parseFloat(neg.toFixed(3)),
            neu: parseFloat(neu.toFixed(3)),
            pos: parseFloat(pos.toFixed(3)),
            compound: parseFloat(compound.toFixed(4)),
          };

          return sentiment_dict;
        } else {
          const sentiment_dict = {
            neg: 0.0,
            neu: 0.0,
            pos: 0.0,
            compound: 0.0,
          };

          return sentiment_dict;
        }
      }
    }
  </script>
  <style>
    :root{
      --bg:#0f0f12;
      --panel:#16161b;
      --muted:#9aa0a6;
      --text:#e8eaed;
      --accent:#8ab4f8;
      --green:#8bc34a;
      --red:#ff6b6b;
      --yellow:#ffd166;
      --border:#23232a;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; padding:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background:var(--bg); color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:10;
      backdrop-filter: blur(8px);
      background: rgba(15,15,18,0.7);
      border-bottom:1px solid var(--border);
    }
    .wrap{max-width:900px; margin:0 auto; padding:16px;}
    h1{font-size:20px; margin:0; font-weight:600; letter-spacing:0.2px}
    .version{font-size:12px; color:var(--muted); margin-left:8px;}
    .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-top:8px}
    .pill{
      border:1px solid var(--border); background:var(--panel); color:var(--text);
      padding:8px 12px; border-radius:10px; font-size:14px;
    }
    input[type="text"], input[type="url"]{
      width:100%; background:var(--panel); border:1px solid var(--border);
      color:var(--text); padding:10px 12px; border-radius:10px; font-size:14px;
    }
    textarea {
      width:100%; min-height:140px; resize:none; background:var(--panel);
      border:1px solid var(--border); color:var(--text);
      padding:12px; border-radius:12px; line-height:1.5; font-size:15px;
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      max-height: 100%; /* relative to the parent’s height */
    }



    button{
      background:var(--accent); color:#0c1116; border:0; padding:10px 14px;
      border-radius:10px; font-weight:600; cursor:pointer; font-size:14px;
    }
    button.secondary{ background:transparent; color:var(--text); border:1px solid var(--border); }
    button.destructive{ background:var(--red); color:#140a0a; }
    small{color:var(--muted)}
    .prompt{font-size:14px; color:var(--yellow); padding:8px 0 0 0}
    .grid{display:grid; grid-template-columns:1fr; gap:14px; margin-top:16px}
    @media(min-width:760px){ .grid{grid-template-columns:2fr 1fr} }
    .card{
      background:var(--panel); 
      border:1px solid var(--border); 
      border-radius:14px; 
      padding:14px;
      /* max-height: calc(80vh - 40px); */
       /* Maximum height with some padding from viewport edges */
      display: flex;
      flex-direction: column;
    }
    .subtle{color:var(--muted); font-size:13px}
    .list{display:flex; flex-direction:column; gap:10px; max-height:420px; overflow:auto}
    .entry{border:1px solid var(--border); border-radius:12px; padding:12px}
    .entry h4{margin:0 0 6px 0; font-size:14px}
    .tags{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px}
    .tag{font-size:12px; background:#1e1e25; border:1px solid var(--border); padding:4px 8px; border-radius:999px; color:var(--muted)}
    .flex{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .card .flex {margin-bottom: 12px; /* space between header and entries */}
    .spacer{flex:1}
    .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; background:#1b1b22; border:1px solid var(--border); padding:2px 6px; border-radius:6px; color:var(--muted)}
    .footer{opacity:0.7; font-size:12px; text-align:center; margin:24px 0}
    .danger{color:var(--red)}
    .good{color:var(--green)}
    .neutral{color:var(--muted)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;}
    .badge{font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid var(--border); background:#1b1b22; color:var(--muted)}
    .editing{border-color:#3a4a63 !important; box-shadow:0 0 0 2px rgba(138,180,248,0.25) inset}
    details.readme{margin-top:16px}
    details.readme summary{cursor:pointer}
    details.llm-settings{margin-top:16px}
    details.llm-settings summary{cursor:pointer}
    .smallnote{font-size:12px; color:var(--muted)}

    .digest-output { line-height:1.6; }
    .digest-output h3 { font-family: ui-monospace, SFMono-Regular, monospace; font-size:1.25rem; margin:0 0 .25rem; }
    .digest-meta { display:grid; grid-template-columns: repeat(2,auto); gap:.5rem 1.25rem; margin:.5rem 0 1rem; }
    .digest-meta b { font-weight:600; }
    .pill { display:inline-block; padding:.15rem .5rem; border-radius:999px; background:var(--panel,#202225); }
    .theme-line { margin:.5rem 0 1rem; }
    .theme-pill { display:inline-block; padding:.2rem .55rem; margin:.2rem .35rem .2rem 0; border-radius:999px; background:#1f2430; border:1px solid #2b3242; font-size:.9rem; }
    .notable { padding:.5rem .75rem; border:1px solid #2b3242; border-radius:.5rem; background:#151821; margin:.5rem 0; }
    .notable small { opacity:.7 }
    .notable.neg::before { content:"↓ "; color:#ff7070; }
    .notable.pos::before { content:"↑ "; color:#6ee7a8; }
    .evidence { margin:.25rem 0 .25rem 1rem; }
    .entities { margin-top:.75rem; font-size:.95rem; }
    .chip { display:inline-block; padding:.1rem .45rem; border-radius:6px; background:#1b1f2a; border:1px solid #2b3242; margin-right:.35rem; }

  </style>

<!-- Streak Counter Functionality -->
<script id="streak-counter">
function ymd(d=new Date()) {
  return d.toISOString().slice(0,10);
}

function updateStreak() {
  const KEY="streak", LAST="streak_last";
  const today=ymd();
  const last=localStorage.getItem(LAST);
  let s=+(localStorage.getItem(KEY)||0);
  
  if(last!==today) {
    const yesterday=ymd(new Date(Date.now()-86400000));
    s = (last===yesterday)? s+1 : 1;
    localStorage.setItem(KEY, s);
    localStorage.setItem(LAST, today);
  }
  document.getElementById("streak")?.replaceChildren("🔥 " + s + " day streak");
}

// Update streak after saving and on page load
document.addEventListener('DOMContentLoaded', updateStreak);
</script>

<!-- --- BEGIN AUTO-EXPAND PATCH V2 (no forced card height) --- -->
<style id="autoexpand-container-patch-v2">
/* Ensure the card uses flex and stretches children, but do NOT force a fixed height */
.card{
  display: flex !important;
  flex-direction: column !important;
  align-items: stretch !important;
  /* keep your original max-height if present; do not set a fixed height */
}

/* The row that contains the textarea should fill remaining space */
.row:has(#entry){
  flex: 1 1 auto !important;
  min-height: 0 !important;     /* critical: allows inner scrolling to work in flex */
  display: flex !important;
  flex-direction: column !important;
}

/* Textarea should stretch with the row, then scroll when capped */
textarea#entry{
  flex: 1 1 auto !important;
  width: 100% !important;
  height: auto !important;       /* allow JS to control height */
  max-height: 100% !important;   /* cap at the row's height */
  overflow-y: auto !important;
  resize: none !important;
  box-sizing: border-box !important;
  margin: 0 !important;          /* avoid vertical centering via margins */
}
</style>

<script id="autoexpand-js-patch-v2">
(function(){
  const ta = document.getElementById("entry");
  if(!ta) return;

  function autoExpand(node){
    // Reset to shrink if needed
    node.style.height = "auto";

    // Cap to the height of its immediate layout row (fills the card)
    const row = node.closest(".row") || node.parentElement;
    const style = getComputedStyle(node);
    const padY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    let cap = Infinity;

    if(row){
      const rStyle = getComputedStyle(row);
      // Available inner height inside the row
      const rowInner = row.clientHeight
        - parseFloat(rStyle.paddingTop)
        - parseFloat(rStyle.paddingBottom);

      // If there are siblings above/below inside the row (titles, toolbars), subtract them
      let used = 0;
      Array.from(row.children).forEach(ch => {
        if(ch !== node){
          used += ch.offsetHeight;
        }
      });

      cap = Math.max(0, rowInner - used);
    }

    const target = Math.min(node.scrollHeight, cap);
    node.style.height = Math.max(0, target) + "px";
  }

  ["input","change"].forEach(ev => ta.addEventListener(ev, () => autoExpand(ta)));
  window.addEventListener("resize", () => autoExpand(ta));
  window.addEventListener("load", () => autoExpand(ta));
  autoExpand(ta);
  window.autoExpand = autoExpand;
})();
</script>
<!-- --- END AUTO-EXPAND PATCH V2 --- -->

</head>
<body>
  <header>  
    <div class="wrap">
      <div class="flex">
        <h1>LightNote <span class="version">v1 — tiny journal</span></h1>
        <nav class="nav">
          <a href="#/write" class="nav-link active">Entries</a>
          <a href="#/analytics" class="nav-link">Analytics</a>
          <a href="#/insights" class="nav-link">Insights</a>
          <a href="#/settings" class="nav-link">Settings</a>
        </nav>
        <div class="spacer"></div>
        <small id="streak" class="subtle" style="margin-right: 12px"></small>
        <span class="badge" id="editBadge" style="display:none" aria-live="polite">Editing…</span>
        <button id="btnQuickSave" title="Ctrl/Cmd+Enter">Quick Save</button>
        <!-- <button class="secondary" id="">New Prompt</button> -->
      </div>
    </div>
  </header>

  <main class="wrap">
    <!-- Write/Entry Section -->
    <div data-route="write">
      <div class="grid">
      <section class="card">
        <div class="subtle">Prompt</div>
        <div id="prompt" class="prompt"></div>
        <div class="row">
          <input id="customPrompt" type="text" placeholder="Edit this prompt for today (optional)" />
        </div>
        <div class="row">
          <textarea id="entry" placeholder="Type freely. Use #tags anywhere."></textarea>
        </div>
        <div class="row">
          <button id="save">Save Entry</button>
          <button class="secondary" id="clear">Clear</button>
          <button class="secondary" id="btnNewPrompt">New Prompt</button>
          <div class="spacer"></div>
          <small id="saveStatus" role="status" aria-live="polite"></small>
        </div>
      </section>

      <aside class="card">
        <div class="subtle">Filters</div>
        <div class="row">
          <input id="search" type="text" placeholder="Search text or #tag" />
        </div>
        <div class="row">
          <input id="fromDate" type="date" /> <input id="toDate" type="date" />
        </div>
        <div class="row">
          <button class="secondary" id="applyFilters">Apply</button>
          <button class="secondary" id="resetFilters">Reset</button>
        </div>

        <hr style="border-color:#23232a; margin:14px 0">

        <div class="subtle">Data</div>
        <div class="row">
          <button class="secondary" id="exportJson">Export JSON</button>
          <button class="secondary" id="exportCsv">Export CSV</button>
        </div>
        <div class="row">
          <input type="file" id="importFile" accept=".json" />
          <button class="secondary" id="importJson">Import</button>
        </div>

        

        <!-- <hr style="border-color:#23232a; margin:14px 0">

        <div class="subtle">Optional LLM webhook</div>
        <div class="row">
          <input id="llmUrl" type="url" placeholder="https://your-endpoint.example/ingest" />
        </div>
        <div class="row">
          <input id="llmToken" type="text" placeholder="Bearer token (optional)" />
        </div>
        <small class="subtle">If set, the latest entry will POST as JSON to your URL after saving.</small> -->
      </aside>
    </div>

    <section class="card" style="margin-top:16px">
      <div class="flex">
        <div>
          <div class="subtle">Entries</div>
          <small id="count" class="subtle"></small>
        </div>
        <div class="spacer"></div>
        <button class="secondary" id="deleteAll"><span class="danger">Delete all</span></button>
      </div>
      <!-- <br></br> -->
      <div id="entries" class="list"></div>
    </section>
    <small class="subtle"><footer>
        <br></br>
        <div class="subtle">
          Sentiment analysis powered by <strong>VADER (Valence Aware Dictionary and sEntiment Reasoner, 2014)</strong>.  
          A simple local rule-based model for sentiment in text.
        </div>
      </footer></small>
    </div>

    <!-- Analytics Section -->
    <div data-route="analytics">
      <section class="card">
        <div class="subtle">Quick Analysis (local, offline)</div>
        <div id="analysis"></div>
      </section>
    </div>
<!-- Insights route -->
<div data-route="insights">
  <!-- Weekly Digest -->
  <section class="card">
    <div class="flex items-center">
      <div>
        <div class="subtle">Weekly Digest</div>
        <small class="subtle" id="digestDates"></small>
      </div>
      <div class="spacer"></div>
      <button class="secondary" id="prevWeek">← Previous</button>
      <button class="secondary" id="thisWeek">This Week</button>
    </div>

    <div id="weeklyDigest" class="digest-output" style="margin-top:16px"></div>

    <div class="row" style="margin-top:20px">
      <button id="saveInsight">Save Insight</button>
      <button class="secondary" id="askAI">Discuss with AI</button>
      <div class="spacer"></div>
      <small id="insightStatus" class="subtle" role="status" aria-live="polite"></small>
    </div>
  </section>

  <!-- Saved Insights -->
  <section class="card" style="margin-top:16px">
    <div class="flex">
      <div>
        <div class="subtle">Saved Insights</div>
        <small id="insightCount" class="subtle"></small>
      </div>
      <div class="spacer"></div>
      <button class="secondary" id="clearInsights"><span class="danger">Clear All</span></button>
    </div>
    <div id="savedInsights" class="list" style="margin-top:12px"></div>
  </section>
</div>


    <!-- Settings Section -->
    <div data-route="settings">
      <details class="card readme">
      <summary><b>README (click to view)</b></summary>
      <div class="row" style="margin-top:10px">
        <div class="smallnote">
          <p><b>What it is:</b> LightNote v1 is a lightweight, private, offline journal. Your notes stay in your browser (localStorage) and never touch a server.</p>
          <p><b>How to use:</b> Open this file in your browser, write in the big box, hit <i>Save</i>. Use Export for backups. Import restores from a previous export.</p>
          <p><b>How to update:</b> Replace this file with a newer version. If you keep using the same browser/profile, your notes remain under the same storage key.</p>
          <p><button class="secondary" id="downloadReadme">Download README.txt</button></p>
        </div>
      </div>
    </details>
    
    <details class="card llm-settings">
      <summary><b>LLM Settings</b></summary>
      <div class="row" style="margin-top:10px; flex-direction:column; gap:8px">
        <label>
          Endpoint URL<br>
          <input id="llmUrl" placeholder="https://api.together.xyz/v1/chat/completions">
        </label>
        <label>
          API Token<br>
          <input id="llmToken" type="password" placeholder="sk-...">
        </label>
        <label>
          Model<br>
          <input id="llmModel" placeholder="meta-llama/Meta-Llama-3-8B-Instruct-Turbo">
        </label>
        <label>
          Timeout (ms)<br>
          <input id="llmTimeout" type="number" min="1000" step="1000" placeholder="60000">
        </label>
        <div class="flex" style="margin-top:6px; gap:8px">
          <button class="secondary" id="saveLlmSettings">Save</button>
          <button class="secondary" id="clearLlmSettings">Clear</button>
        </div>
        <small class="subtle">Stored in browser localStorage only.</small>
      </div>
    </details>




  </main>

  <!-- <div class="footer">All data stays in your browser (localStorage). No servers, no tracking.</div> -->
<script>
  // Load saved settings into fields
  function loadLlmSettings() {
    document.getElementById("llmUrl").value =
      localStorage.getItem("ln.llm.url") || "";
    document.getElementById("llmToken").value =
      localStorage.getItem("ln.llm.token") || "";
    document.getElementById("llmModel").value =
      localStorage.getItem("ln.llm.model") || "";
    document.getElementById("llmTimeout").value =
      localStorage.getItem("ln.llm.timeout") || "";
  }

  // Save button
  document.getElementById("saveLlmSettings").onclick = () => {
    localStorage.setItem("ln.llm.url", document.getElementById("llmUrl").value.trim());
    localStorage.setItem("ln.llm.token", document.getElementById("llmToken").value.trim());
    localStorage.setItem("ln.llm.model", document.getElementById("llmModel").value.trim());
    localStorage.setItem("ln.llm.timeout", document.getElementById("llmTimeout").value.trim());
    alert("LLM settings saved to localStorage.");
  };

  // Clear button
  document.getElementById("clearLlmSettings").onclick = () => {
    ["ln.llm.url","ln.llm.token","ln.llm.model","ln.llm.timeout"].forEach(k => localStorage.removeItem(k));
    loadLlmSettings();
    alert("LLM settings cleared.");
  };

  // Auto-load on open
  loadLlmSettings();
</script>


<script>
(function(){
  const prompts = JSON.parse(localStorage.getItem('lightnote.prompts')||'null') || [
    "What feels lighter than yesterday?",
    "One thing I can control today is…",
    "What drained me vs. what gave a spark?",
    "What am I avoiding? What tiny step could I take?",
    "A moment I'm grateful for (however small)…",
    "What do I actually need right now?",
    "If it could be 1% better by tonight, what would I do?",
    "What's one thing I want to remember about today?",
    "Where in my body do I feel tension right now?",
    "What would I do if I was being kind to myself?",
    "What did I learn (or re-learn) today?",
    "What's something small that mattered more than I expected?",
    "What am I proud of, even if no one else sees it?",
    "If I paused for 5 minutes, what would I notice?",
    "What could I let go of today, just a little bit?",
    "Where did I feel most like myself today?",
    "What's a story I keep telling myself — and is it true?"

  ];

  const el = {
    prompt: document.getElementById('prompt'),
    customPrompt: document.getElementById('customPrompt'),
    entry: document.getElementById('entry'),
    save: document.getElementById('save'),
    clear: document.getElementById('clear'),
    saveStatus: document.getElementById('saveStatus'),
    entries: document.getElementById('entries'),
    count: document.getElementById('count'),
    search: document.getElementById('search'),
    fromDate: document.getElementById('fromDate'),
    toDate: document.getElementById('toDate'),
    applyFilters: document.getElementById('applyFilters'),
    resetFilters: document.getElementById('resetFilters'),
    exportJson: document.getElementById('exportJson'),
    exportCsv: document.getElementById('exportCsv'),
    importJson: document.getElementById('importJson'),
    importFile: document.getElementById('importFile'),
    analysis: document.getElementById('analysis'),
    btnNewPrompt: document.getElementById('btnNewPrompt'),
    btnQuickSave: document.getElementById('btnQuickSave'),
    llmUrl: document.getElementById('llmUrl'),
    llmToken: document.getElementById('llmToken'),
    deleteAll: document.getElementById('deleteAll'),
    editBadge: document.getElementById('editBadge'),
    downloadReadme: document.getElementById('downloadReadme'),
  };

  const STORAGE_KEY = 'lightnote.entries.v1';
  let editingId = null;

  // Auto-expand textarea
  function autoExpand(node) {
  node.style.height = 'auto';
  let newHeight = node.scrollHeight;
  const max = parseInt(window.getComputedStyle(node).maxHeight);
  if (newHeight > max) {
    newHeight = max;
  }
  node.style.height = newHeight + 'px'; 
}

  
  el.entry.addEventListener('input', ()=> autoExpand(el.entry));
  window.addEventListener('load', ()=> autoExpand(el.entry));

  let lastPromptIndex = -1;

function pickPrompt() {
  let idx;
  do {
    idx = Math.floor(Math.random() * prompts.length);
  } while (idx === lastPromptIndex && prompts.length > 1);

  lastPromptIndex = idx;
  const txt = prompts[idx];

  // side effects
  el.prompt.textContent = txt;
  el.customPrompt.value = "";

  return txt; // optional, in case you still want the value
}

  function load(){
    return JSON.parse(localStorage.getItem(STORAGE_KEY)||'[]');
  }
  function saveAll(items){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
  }

  function parseTags(text){
    const set = new Set();
    text.replace(/(^|\s)#([a-zA-Z0-9_\-]+)/g, (_,s,tag)=>{ set.add(tag.toLowerCase()); return _; });
    return Array.from(set);
  }

  function getSentiment(text) {
    const { compound, pos, neu, neg } = SentimentIntensityAnalyzer.polarity_scores(text || "");
    const label = compound >= 0.05 ? "positive" :
                  compound <= -0.05 ? "negative" : "neutral";
    return { compound, pos, neu, neg, label };
  }

  function renderList(){
    const q = (el.search.value||"").trim().toLowerCase();
    const from = el.fromDate.value ? new Date(el.fromDate.value) : null;
    const to = el.toDate.value ? new Date(el.toDate.value) : null;

    const items = load().sort((a,b)=> b.created - a.created);
    const filtered = items.filter(it=>{
      const dt = new Date(it.created);
      if(from && dt < from) return false;
      if(to){
        const end = new Date(to); end.setDate(end.getDate()+1); // inclusive
        if(dt >= end) return false;
      }
      if(!q) return true;
      if(it.text.toLowerCase().includes(q)) return true;
      if((it.tags||[]).some(t=>('#'+t)===q || t.includes(q.replace('#','')))) return true;
      return false;
    });

    el.count.textContent = `${filtered.length} of ${items.length} shown`;

    el.entries.innerHTML = "";
    filtered.forEach(it=>{
    const div = document.createElement('div');
    div.className = 'entry';
    const d = new Date(it.created);
    const hh = d.toLocaleString();
    
    // VADER wrapper result
    const { compound, label } = getSentiment(it.text);

    // map label -> CSS class
    const moodClass =
      label === 'positive' ? 'good' :
      label === 'negative' ? 'danger' : 'neutral';

    // arrow based on VADER thresholds
    const arrow =
      compound >= 0.05 ? '↑' :
      compound <= -0.05 ? '↓' : '·';

    // optional numeric display if you ever want it
    const sn = compound.toFixed(2);

    // edited timestamp (define BEFORE building HTML)
    const updated = it.updated
      ? ` &middot; <span class="mono subtle">edited ${new Date(it.updated).toLocaleString()}</span>`
      : "";

    // build entry HTML
    div.innerHTML = `
      <h4>${hh} <span class="${moodClass} mono">• ${arrow} mood</span>${updated}</h4>
      <div class="subtle">Prompt: ${escapeHtml(it.prompt || '—')}</div>
      <p style="white-space:pre-wrap; margin:10px 0 0 0">${escapeHtml(it.text)}</p>
      <div class="tags">${(it.tags || []).map(t => `<span class="tag">#${t}</span>`).join('')}</div>
      <div class="flex" style="margin-top:8px">
        <button class="secondary" data-edit="${it.id}">Edit</button>
        <button class="secondary destructive" data-del="${it.id}">Delete</button>
        <div class="spacer"></div>
        <small class="subtle mono">id:${it.id.slice(0,8)}</small>
      </div>
    `;

    el.entries.appendChild(div);

    });

    el.entries.querySelectorAll('button[data-del]').forEach(btn=>{
      btn.onclick = ()=>{
        const id = btn.getAttribute('data-del');
        const items = load().filter(x=>x.id!==id);
        saveAll(items); renderList(); analyze();
        if(editingId === id){ endEditing(); }
      };
    });
    el.entries.querySelectorAll('button[data-edit]').forEach(btn=>{
      btn.onclick = ()=>{
        const id = btn.getAttribute('data-edit');
        const it = load().find(x=>x.id===id);
        if(!it) return;
        el.customPrompt.value = it.prompt||"";
        el.entry.value = it.text;
        editingId = id;
        el.entry.classList.add('editing');
        el.editBadge.style.display = 'inline-block';
        autoExpand(el.entry);
        window.scrollTo({top:0, behavior:'smooth'});
        status("Editing existing entry. Click Save to update, Clear to cancel.");
      };
    });
  }

  function tokenize(text) {
    return text.toLowerCase()
      .replace(/[^a-z0-9\s#]/g, '')
      .split(/\s+/)
      .filter(Boolean);
  }

  function histograms(entries){
    const byDay = new Map();
    const byDow = new Array(7).fill(0);
    const byHour = new Array(24).fill(0);
    const freq = new Map();
    // Initialize 7×24 heatmap grid with zeros
    const heatmap = Array(7).fill().map(() => Array(24).fill(0));
    
    for(const e of entries){
      const d = new Date(e.created);
      const day = d.toISOString().slice(0,10);
      byDay.set(day, (byDay.get(day)||0)+1);
      const dow = d.getDay(); // 0=Sun
      const hour = d.getHours();
      byDow[dow]++;
      byHour[hour]++;
      heatmap[dow][hour]++;
      
      for(const t of tokenize(e.text)){
        if(t.length<3 || STOP.has(t)) continue;
        freq.set(t, (freq.get(t)||0)+1);
      }
    }
    
    return {
      byDay: [...byDay.entries()].sort((a,b)=>a[0].localeCompare(b[0])),
      byDow,
      byHour,
      heatmap,
      topWords: [...freq.entries()].sort((a,b)=>b[1]-a[1]).slice(0,25)
    };
  }

  function renderHeatmap(data) {
    const daysOfWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const maxValue = Math.max(...data.flat());
    
    // Create header row with hour labels
    let html = '<div></div>'; // Empty cell for row labels
    for (let h = 0; h < 24; h++) {
      html += `<div class="heatmap-header">${h}</div>`;
    }
    
    // Create data rows
    data.forEach((row, i) => {
      html += `<div class="heatmap-label">${daysOfWeek[i]}</div>`;
      row.forEach((value, h) => {
        const intensity = maxValue ? (value / maxValue) : 0;
        const alpha = 0.1 + (intensity * 0.9); // minimum opacity of 0.1
        html += `<div class="heatmap-cell" style="background: rgba(138,180,248,${alpha})" 
          data-tooltip="${value} entries on ${daysOfWeek[i]} at ${h}:00"></div>`;
      });
    });
    
    return html;
  }

  function analyze(){
    const items = load();
    if (!items.length) {
      el.analysis.innerHTML = '<div class="card"><div class="subtle">No entries yet. Start writing to see analytics.</div></div>';
      return;
    }
    
    const total = items.length;
    const words = items.flatMap(it=> it.text.trim().split(/\s+/)).filter(Boolean);
    const wc = words.length;
    
    // Get tag counts
    const tagCounts = {};
    items.forEach(it=> (it.tags||[]).forEach(t=> tagCounts[t]=(tagCounts[t]||0)+1 ));
    const topTags = Object.entries(tagCounts).sort((a,b)=>b[1]-a[1]).slice(0,10);

    // Get histograms and patterns
    const patterns = histograms(items);

    // Get mood analysis
    const mood = items.map(it => getSentiment(it.text).compound);
    const avgMood = mood.length
      ? (mood.reduce((a, b) => a + b, 0) / mood.length).toFixed(2)
      : '—';

    // STOP set is now defined at the top level of the script

    // Use the histograms function we added for word frequency
    const hist = histograms(items);
    const topWords = hist.topWords.slice(0, 18);


    let avgLabel = 'neutral';
    if (avgMood !== '—') {
      const n = parseFloat(avgMood);
      if (n >= 0.05) avgLabel = 'positive';
      else if (n <= -0.05) avgLabel = 'negative';
    }

    const daysOfWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    
    // Find max values for scaling
    const maxHour = Math.max(...patterns.byHour);
    const maxDow = Math.max(...patterns.byDow);
    
    // Create hour bars
    const hourBars = patterns.byHour.map((count, i) => {
      const height = count ? (count / maxHour * 100) : 0;
      return `<div class="bar-col">
        <div class="bar" style="height:${height}%" title="${count} entries at ${i}:00"></div>
        <div class="bar-label">${i}</div>
      </div>`;
    }).join('');

    // Create day of week bars
    const dowBars = patterns.byDow.map((count, i) => {
      const height = count ? (count / maxDow * 100) : 0;
      return `<div class="bar-col">
        <div class="bar" style="height:${height}%" title="${count} entries on ${daysOfWeek[i]}"></div>
        <div class="bar-label">${daysOfWeek[i]}</div>
      </div>`;
    }).join('');

    el.analysis.innerHTML = `
      <style>
        .analytics-container {
          margin: 0;
          padding: 0;
        }
        .analytics-container .card {
          padding: 16px;
        }
        .charts-container {
          padding: 0;
          margin-top: 12px;
        }
        .chart-section {
          margin-bottom: 32px;
        }
        .chart-section:last-child {
          margin-bottom: 0;
        }
        .chart-title {
          margin: 8px 0 16px 0;
        }
        .word-cloud {
          padding: 4px 0;
          gap: 8px;
          flex-wrap: wrap;
        }
        .chart {
          display: flex;
          height: 100px;
          gap: 4px;
          position: relative;
          align-items: flex-end;
          padding-bottom: 24px;
          margin: 0;
        }
        .chart:after {
          content: '';
          position: absolute;
          bottom: 20px;
          left: 0;
          right: 0;
          height: 1px;
          background: var(--border);
        }
        .bar-col {
          flex: 1;
          display: flex;
          flex-direction: column;
          justify-content: flex-end;
          align-items: center;
          min-width: 20px;
          position: relative;
          height: 100%;
        }
        .bar {
          width: 100%;
          min-height: 1px;
          background: var(--accent);
          opacity: 0.7;
          transition: all 0.2s;
          border-radius: 2px 2px 0 0;
          margin-top: auto;
        }
        .bar:hover {
          opacity: 1;
          box-shadow: 0 0 0 2px rgba(138,180,248,0.25);
        }
        .bar-label {
          font-size: 11px;
          color: var(--muted);
          position: absolute;
          bottom: 0;
          width: 100%;
          text-align: center;
        }
        .heatmap {
          display: grid;
          grid-template-columns: auto repeat(24, 1fr);
          gap: 1px;
          padding: 12px 0;
          font-size: 11px;
        }
        .heatmap-label {
          color: var(--muted);
          padding: 4px 8px;
          text-align: right;
          display: flex;
          align-items: center;
        }
        .heatmap-cell {
          aspect-ratio: 1;
          border-radius: 2px;
          position: relative;
        }
        .heatmap-cell:hover::after {
          content: attr(data-tooltip);
          position: absolute;
          bottom: 100%;
          left: 50%;
          transform: translateX(-50%);
          background: var(--panel);
          color: var(--text);
          padding: 4px 8px;
          border-radius: 4px;
          font-size: 11px;
          white-space: nowrap;
          z-index: 1;
          border: 1px solid var(--border);
        }
        .heatmap-header {
          color: var(--muted);
          text-align: center;
          font-size: 10px;
        }
      </style>

      <div class="analytics-container">
        <div class="analytics-wrap" style="max-width:900px; margin:0 auto">
          <div class="grid" style="grid-template-columns:1fr 1fr; gap:16px">
            <div class="card">
              <div class="subtle">Totals</div>
              <div class="row" style="margin-top:12px">
                <div class="pill">Entries: <b>${total}</b></div>
                <div class="pill">Words: <b>${wc}</b></div>
                <div class="pill">Avg mood: <b>${avgMood} (${avgLabel})</b></div>
              </div>
            </div>
            <div class="card">
              <div class="subtle">Top tags</div>
              <div class="tags" style="margin-top:12px">${topTags.map(([t,c])=>`<span class="tag">#${t} × ${c}</span>`).join('') || '<small class="subtle">No tags yet.</small>'}</div>
            </div>
          </div>

          <div class="card" style="margin-top:16px">
            <div class="subtle">Entry patterns</div>
            <div class="charts-container">
              <div class="chart-section">
                <div class="subtle chart-title">Writing patterns (day × hour)</div>
                <div class="heatmap">
                  ${renderHeatmap(patterns.heatmap)}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="wrap" style="margin-top:16px">
        <div class="card">
          <div class="subtle">Most common words</div>
          <div class="tags word-cloud" style="margin-top:12px">${patterns.topWords.map(([w,c])=>`<span class="tag">${w} × ${c}</span>`).join('') || '<small class="subtle">Start writing to see patterns.</small>'}</div>
        </div>
      </div>
    `;
  }

  function endEditing(){
    editingId = null;
    el.editBadge.style.display = 'none';
    el.entry.classList.remove('editing');
  }

  function saveEntry(){
  const items = load();
  const prompt = (el.customPrompt.value.trim() || el.prompt.textContent || "").trim();
  const text = el.entry.value.trim();
  if(!text){
    pulse(el.entry);
    status("Nothing to save.", true);
    return;
  }

  const { compound, label } = getSentiment(text);
  
  const tags = parseTags(text);

  if(editingId){
    const idx = items.findIndex(x=>x.id===editingId);
    if(idx !== -1){
      items[idx] = { 
        ...items[idx], 
        text, 
        prompt, 
        tags, 
        updated: Date.now(),
        meta: { ...(items[idx].meta||{}), sent: { compound } }
      };
      saveAll(items);
      status("Updated entry.");
      endEditing();
    }else{
      addNew(items, prompt, text, tags, compound);
      status("Saved (previous entry not found).");
    }
  }else{
    addNew(items, prompt, text, tags, compound);
    status("Saved.");
  }
  el.entry.value = "";
  autoExpand(el.entry);
  renderList(); analyze();
  updateStreak();
  // maybeSendToLLM(items[items.length-1]);
}


  function addNew(items, prompt, text, tags, compound){
    const id = (crypto.randomUUID ? crypto.randomUUID() : String(Date.now())+Math.random().toString(36).slice(2));
    const created = Date.now();
    const entry = { id, created, prompt, text, tags, compound };
    items.push(entry);
    saveAll(items);
  }

  async function maybeSendToLLM(entry){
    const url = el.llmUrl.value.trim();
    if(!url) return;
    try{
      const headers = { 'Content-Type':'application/json' };
      const tok = el.llmToken.value.trim();
      if(tok) headers['Authorization'] = tok.startsWith('Bearer ')? tok : ('Bearer '+tok);
      const res = await fetch(url, { method:'POST', headers, body: JSON.stringify(entry) });
      if(!res.ok) throw new Error('HTTP '+res.status);
      status("Saved + sent to LLM endpoint.");
    }catch(e){
      status("Saved locally. Webhook failed: "+e.message, true);
    }
  }

  function exportJson(){
    const data = load();
    download(JSON.stringify(data,null,2), "lightnote-export.json", "application/json");
  }
  function exportCsv(){
    const items = load().sort((a,b)=> a.created - b.created);
    const esc = s=> '"'+ String(s).replace(/"/g,'""') +'"';
    const rows = [["id","created_iso","updated_iso","prompt","text","tags"]]
      .concat(items.map(it=>[
        it.id,
        new Date(it.created).toISOString(),
        it.updated ? new Date(it.updated).toISOString() : "",
        it.prompt||"",
        it.text.replace(/\n/g,'\\n'),
        (it.tags||[]).join(' ')
      ]));
    const csv = rows.map(r=>r.map(esc).join(',')).join('\n');
    download(csv, "lightnote-export.csv", "text/csv");
  }

  function importJson(file){
    const reader = new FileReader();
    reader.onload = e=>{
      try{
        const data = JSON.parse(String(e.target.result));
        if(!Array.isArray(data)) throw new Error("Invalid JSON format");
        const existing = load();
        const ids = new Set(existing.map(x=>x.id));
        const merged = existing.concat(data.filter(x=> x && x.id && !ids.has(x.id)));
        saveAll(merged);
        renderList(); analyze();
        status("Import complete.");
      }catch(err){
        status("Import failed: "+err.message, true);
      }
    };
    reader.readAsText(file);
  }

  function download(content, filename, type){
    const blob = new Blob([content], {type});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 250);
  }

  function status(msg, isError=false){
    el.saveStatus.textContent = msg;
    el.saveStatus.style.color = isError ? 'var(--red)' : 'var(--muted)';
    setTimeout(()=>{ el.saveStatus.textContent=""; }, 4000);
  }

  function pulse(node){
    node.animate([{boxShadow:'0 0 0 0 rgba(138,180,248,0.6)'},{boxShadow:'0 0 0 8px rgba(138,180,248,0)'}], {duration:600});
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c=> ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":'&#039;'}[c]) );
  }

  // Event wiring
  el.save.onclick = saveEntry;
  el.clear.onclick = ()=>{
    el.entry.value=""; el.customPrompt.value="";
    autoExpand(el.entry);
    if(editingId){ endEditing(); status("Edit canceled."); } else { status("Cleared."); }
  };
  el.applyFilters.onclick = renderList;
  el.resetFilters.onclick = ()=>{ el.search.value=""; el.fromDate.value=""; el.toDate.value=""; renderList(); };
  el.exportJson.onclick = exportJson;
  el.exportCsv.onclick = exportCsv;
  el.importJson.onclick = ()=>{
    if(!el.importFile.files[0]){ status("Choose a JSON file first.", true); return; }
    importJson(el.importFile.files[0]);
  };
  el.btnNewPrompt.onclick = pickPrompt;
  el.btnQuickSave.onclick = saveEntry;
  el.deleteAll.onclick = ()=>{
    if(confirm("Delete ALL entries? This cannot be undone.")){
      localStorage.setItem(STORAGE_KEY, JSON.stringify([]));
      renderList(); analyze(); endEditing();
      status("All entries deleted.");
    }
  };

  el.downloadReadme.onclick = ()=>{
  const readme = `LightNote v1 — tiny offline journal
  -----------------------------------

  QUICK START
  1. Open index.html in your browser (Chrome, Firefox, Safari).
  2. Start typing. Press Save (or Ctrl/Cmd+Enter) to store an entry.
  3. Export/Import your notes anytime for backup.

  WHAT IT IS
  LightNote is a lightweight, private, offline journal.
  - Runs entirely in your browser (no installs, no accounts).
  - Notes are saved only in your browser’s localStorage.
  - Your data never leaves your device.

  HOW TO USE
  1. Open index.html in your browser.
  2. Type freely in the big box.
  3. Click Save Entry (or press Ctrl/Cmd+Enter for Quick Save).
  4. Use Export for backups (JSON/CSV). Import restores from a previous export.

  FEATURES
  - 📝 Prompts: Get a daily journaling question (or write your own).
  - 🔎 Search & Filters: Filter entries by text, tag, or date range.
  - 🔒 Offline & Private: All notes stay in your browser (no servers, no tracking).
  - 📊 Quick Analysis:
    • Entry + word counts
    • Average mood (sentiment analysis)
    • Top words (stop words removed)
    • Most-used tags
  - 🔥 Streak Counter: Tracks your daily journaling streak.
  - 💾 Backup/Restore: Export JSON/CSV, import back anytime.

  HOW TO UPDATE
  Replace index.html with a newer version.
  As long as you keep the same browser/profile, your notes stay under the same storage key:
  lightnote.entries.v1

  TIPS
  - Use #tags anywhere inside an entry to organise.
  - Quick save with Ctrl/Cmd+Enter.

  DATA & PRIVACY
  - Everything stays on-device.
  - No accounts. No cloud. No tracking.
  `;
    download(readme, "README.txt", "text/plain");
  };

  document.addEventListener('keydown', (e)=>{
    if((e.metaKey||e.ctrlKey) && e.key==='Enter'){ saveEntry(); }
  });

  document.addEventListener('keydown', (e)=>{
    if((e.metaKey||e.ctrlKey) && e.key==='Enter'){ saveEntry(); }
  });

  // Init
  pickPrompt();
  renderList();
  analyze();
})();
</script>
</body>


</html>
